/* +TOKENIZER+V4 +LOGIC + + + + + + + + + + + + + + + + + + + + + + +
-----OVERVIEW:
FSM WHICH TAKES IN STRING INPUT AND THEN CONVERTS TO INFIX TOKENS 
TO BE PROCESSED IN A SHUNTING YARD CLASS TO CONVERT TO POSTFIX-

START AT S0 AND THEN TRANSIONS TO ACCORDING STATE UNTIL ARRIVING 
AT AN ACCEPTING STATE-

ONCE ARRIVING AT ACCEPTING STATE WILL PKG TOKENS IN A WRAPPER (TK_DATA)
TO BE SENT TO ACCORDING CLASS TO CREATE TOKEN-

IMPLEMENTED IS AN INVALID STATE TO PROCESS INVALID INPUTS FROM USER- 
SINCE STATES ARE THEIR OWN FUNCTION WE ARE ABLE TO ADD ADDITIONAL STATES
BY DEFINING ANOTHER FUNCTION-

EACH STATE IS MAPPED TO A CORRESPONDING INT AND IS STORED AS A FUNCTION POINTER 
WHICH THEN WILL POINT TO A SEQUENCE OF EVENT STATES EVENTUALLY LEADING TO ACCEPTING STATE-

ENCAPSULATING FUNCTION CAN BE CALLED RECURSIVELY TO HANDLE COMPOSITE FUNCTIONS-

(in this process we will inject another string to tokenize in the middle of the main process)
we are able to do this because tokens are getting pushed to the infix queue char by char 
instead of all at once; 

WE CAN ALSO SET A PRE-INFIX AND ADD ON TO IT (store answer functionality?)
This is my 3rd tokenizer iteration;


THE ID SYSTEM :
ALL TOKENS WILL HAVE AN ASSOCIATIVE ID WHICH WILL CORRESPOND TO THEIR FUNCTIONALITY
THOUGH NOT PARTICUALLY IMPORTANT TO NUMERICAL IT CAN SERVE AS A WAY TO MAP OPERATIONS
IDS ARE INT VALUES AND WE CAN CATEGORIZE FUNCTIONS BY ID I.E. 

FUNCTIONS IN 100-150 could be functions that take in 2 arguments while functions in 
151-200 range can take in 2 aruguments etc.
THIS COULD ELIMINTE THE PRECEDENCE SYSTEM 
and even allow us to handle same name functions with different functions
ie '-' OPERATOR vs '-' UNARY OPERATOR
